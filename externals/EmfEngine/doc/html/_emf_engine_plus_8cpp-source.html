<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>EmfEngine Commercial: C:/EmfEngine/EmfEngineCommercial-2.0.2/src/EmfEnginePlus.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>C:/EmfEngine/EmfEngineCommercial-2.0.2/src/EmfEnginePlus.cpp</h1><a href="_emf_engine_plus_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/***************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment">        File                 : EmfEnginePlus.cpp</span>
<a name="l00003"></a>00003 <span class="comment">        Project              : EmfEngine Commercial</span>
<a name="l00004"></a>00004 <span class="comment">        --------------------------------------------------------------------</span>
<a name="l00005"></a>00005 <span class="comment">        Copyright            : (C) 2009 - 2014 by Ion Vasilief</span>
<a name="l00006"></a>00006 <span class="comment">        Email (use @ for *)  : ion_vasilief*yahoo.fr</span>
<a name="l00007"></a>00007 <span class="comment">        Description          : Enables the export of QPainter grafics to</span>
<a name="l00008"></a>00008 <span class="comment">                                                   Windows Enhanced Metafiles (.emf) by using GDI+ calls</span>
<a name="l00009"></a>00009 <span class="comment"> ***************************************************************************/</span>
<a name="l00010"></a>00010 
<a name="l00011"></a>00011 <span class="comment">/***************************************************************************</span>
<a name="l00012"></a>00012 <span class="comment"> *</span>
<a name="l00013"></a>00013 <span class="comment"> *  Commercial Usage</span>
<a name="l00014"></a>00014 <span class="comment"> *</span>
<a name="l00015"></a>00015 <span class="comment"> *  Licensees holding valid EmfEngine Commercial licenses may use this file in</span>
<a name="l00016"></a>00016 <span class="comment"> *  accordance with the EmfEngine Commercial License Agreement provided</span>
<a name="l00017"></a>00017 <span class="comment"> *  with the Software or, alternatively, in accordance with the terms</span>
<a name="l00018"></a>00018 <span class="comment"> *  contained in a written agreement between you and ProIndep Serv S.r.l.</span>
<a name="l00019"></a>00019 <span class="comment"> *</span>
<a name="l00020"></a>00020 <span class="comment"> ***************************************************************************/</span>
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 <span class="preprocessor">#include "<a class="code" href="_emf_engine_8h.html">EmfEngine.h</a>"</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;QFontDatabase&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;QDir&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;QBuffer&gt;</span>
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;math.h&gt;</span>
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 <span class="keyword">using namespace </span>Gdiplus;
<a name="l00030"></a>00030 
<a name="l00031"></a><a class="code" href="_emf_engine_plus_8cpp.html#347dbe3883d1fb2f340fff44fb2660a3">00031</a> <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="_emf_engine_plus_8cpp.html#347dbe3883d1fb2f340fff44fb2660a3">ARGB2Pixel</a>(<span class="keywordtype">int</span> alpha, <span class="keywordtype">int</span> r, <span class="keywordtype">int</span> g, <span class="keywordtype">int</span> b){
<a name="l00032"></a>00032         <span class="keywordflow">if</span> (alpha &gt; 255)
<a name="l00033"></a>00033                 alpha = 255;
<a name="l00034"></a>00034         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (alpha &lt; 0)
<a name="l00035"></a>00035                 alpha = 0;
<a name="l00036"></a>00036 
<a name="l00037"></a>00037         <span class="keywordflow">if</span> (r &gt; 255)
<a name="l00038"></a>00038                 r = 255;
<a name="l00039"></a>00039         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (r &lt; 0)
<a name="l00040"></a>00040                 r = 0;
<a name="l00041"></a>00041 
<a name="l00042"></a>00042         <span class="keywordflow">if</span> (g &gt; 255)
<a name="l00043"></a>00043                 g = 255;
<a name="l00044"></a>00044         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (g &lt; 0)
<a name="l00045"></a>00045                 g = 0;
<a name="l00046"></a>00046 
<a name="l00047"></a>00047         <span class="keywordflow">if</span> (b &gt; 255)
<a name="l00048"></a>00048                 b = 255;
<a name="l00049"></a>00049         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (b &lt; 0)
<a name="l00050"></a>00050                 b = 0;
<a name="l00051"></a>00051 
<a name="l00052"></a>00052         <span class="comment">// shift r and g to encode</span>
<a name="l00053"></a>00053         r = (r &lt;&lt; 16);
<a name="l00054"></a>00054         g = (g &lt;&lt; 8 );
<a name="l00055"></a>00055         <span class="keywordflow">return</span> (((alpha &lt;&lt; 24 )&amp;0xff000000) | r | g| b);
<a name="l00056"></a>00056 }
<a name="l00057"></a>00057 
<a name="l00058"></a>00058 <span class="comment">// Given a QImage - get an integer encoded data of the pixels</span>
<a name="l00059"></a><a class="code" href="_emf_engine_plus_8cpp.html#fcec0a95fff23a495a52ea0cbb04abef">00059</a> <span class="keywordtype">int</span> * <a class="code" href="_emf_engine_plus_8cpp.html#fcec0a95fff23a495a52ea0cbb04abef">image2PixelData</a>(<span class="keyword">const</span> QImage&amp; image, <span class="keywordtype">double</span> opacity)
<a name="l00060"></a>00060 {
<a name="l00061"></a>00061         <span class="comment">// get width and height of Bitmap</span>
<a name="l00062"></a>00062         <span class="keywordtype">int</span> width = image.width();
<a name="l00063"></a>00063         <span class="keywordtype">int</span> height = image.height();
<a name="l00064"></a>00064 
<a name="l00065"></a>00065         <span class="comment">// make sure these are valid</span>
<a name="l00066"></a>00066         <span class="keywordflow">if</span> (width *height &lt;= 0)
<a name="l00067"></a>00067                 <span class="keywordflow">return</span> NULL;
<a name="l00068"></a>00068 
<a name="l00069"></a>00069         <span class="comment">// allocate memory for pixel data</span>
<a name="l00070"></a>00070         <span class="keywordtype">int</span> *pixelData_ARGB = <span class="keyword">new</span> <span class="keywordtype">int</span>[width*height];
<a name="l00071"></a>00071         <span class="keywordflow">if</span> (pixelData_ARGB == NULL)
<a name="l00072"></a>00072                 <span class="keywordflow">return</span> NULL;
<a name="l00073"></a>00073 
<a name="l00074"></a>00074         <span class="comment">// get the pixel values from the image and encode into the array allocated above.</span>
<a name="l00075"></a>00075         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; height; y++){
<a name="l00076"></a>00076                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; ++x ){
<a name="l00077"></a>00077                         QRgb p = image.pixel(x, y);
<a name="l00078"></a>00078                         pixelData_ARGB[y*width + x] = <a class="code" href="_emf_engine_plus_8cpp.html#347dbe3883d1fb2f340fff44fb2660a3">ARGB2Pixel</a>(qRound(opacity*qAlpha(p)), qRed(p), qGreen(p), qBlue(p));
<a name="l00079"></a>00079                 }
<a name="l00080"></a>00080         }
<a name="l00081"></a>00081 
<a name="l00082"></a>00082         <span class="comment">// return the pixel data array</span>
<a name="l00083"></a>00083         <span class="keywordflow">return</span> (pixelData_ARGB);
<a name="l00084"></a>00084 }
<a name="l00085"></a>00085 
<a name="l00086"></a><a class="code" href="_emf_engine_plus_8cpp.html#060093cbe9e19ad814a1c36f2a5bb475">00086</a> Bitmap * <a class="code" href="_emf_engine_plus_8cpp.html#060093cbe9e19ad814a1c36f2a5bb475">PixelData2BitMap</a>(<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height, <span class="keywordtype">int</span> *pixData_ARGB)
<a name="l00087"></a>00087 {
<a name="l00088"></a>00088         <span class="comment">// create a temporary Bitmap</span>
<a name="l00089"></a>00089         Bitmap *bitmap = <span class="keyword">new</span> Bitmap(width, height, PixelFormat32bppARGB);
<a name="l00090"></a>00090 
<a name="l00091"></a>00091         BitmapData bmData;
<a name="l00092"></a>00092         Rect rect(0, 0, width, height);
<a name="l00093"></a>00093         bitmap-&gt;LockBits(&amp;rect, ImageLockModeRead | ImageLockModeWrite, PixelFormat32bppARGB, &amp;bmData);
<a name="l00094"></a>00094 
<a name="l00095"></a>00095         <span class="keywordtype">int</span> stride = bmData.Stride;
<a name="l00096"></a>00096         BYTE *p = (BYTE *)((<span class="keywordtype">void</span> *)bmData.Scan0);
<a name="l00097"></a>00097         <span class="keywordtype">int</span> nOffset = stride - width*4;<span class="comment">// bytes to skip at end of each row</span>
<a name="l00098"></a>00098 
<a name="l00099"></a>00099         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; height;y++){
<a name="l00100"></a>00100                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; ++x ){<span class="comment">// GDI lies about RGB - internally it's BGR</span>
<a name="l00101"></a>00101                         <span class="keywordtype">int</span> pixel = pixData_ARGB[y*width+x];
<a name="l00102"></a>00102                         p[3] = (BYTE) ((pixel &gt;&gt; 24) &amp; 0xff);<span class="comment">// alpha</span>
<a name="l00103"></a>00103                         p[2] = (BYTE) ((pixel &gt;&gt; 16) &amp; 0xff);<span class="comment">// pixel red</span>
<a name="l00104"></a>00104                         p[1] = (BYTE) ((pixel &gt;&gt; 8 ) &amp; 0xff);<span class="comment">// pixel green</span>
<a name="l00105"></a>00105                         p[0] = (BYTE) ((pixel      ) &amp; 0xff);<span class="comment">// pixel blue</span>
<a name="l00106"></a>00106                         p += 4;
<a name="l00107"></a>00107                 }
<a name="l00108"></a>00108                 p += nOffset;
<a name="l00109"></a>00109         }
<a name="l00110"></a>00110         bitmap-&gt;UnlockBits(&amp;bmData);
<a name="l00111"></a>00111         <span class="keywordflow">return</span> bitmap;
<a name="l00112"></a>00112 }
<a name="l00113"></a>00113 
<a name="l00114"></a><a class="code" href="_emf_engine_plus_8cpp.html#2cd7d484029373b8c70e7e1dc161fcae">00114</a> Bitmap* <a class="code" href="_emf_engine_plus_8cpp.html#2cd7d484029373b8c70e7e1dc161fcae">pixToBitmap</a>(<span class="keyword">const</span> QPixmap&amp; pix, <span class="keywordtype">double</span> opacity)
<a name="l00115"></a>00115 {
<a name="l00116"></a>00116         QImage image = pix.toImage();
<a name="l00117"></a>00117         <span class="keywordflow">return</span> <a class="code" href="_emf_engine_plus_8cpp.html#060093cbe9e19ad814a1c36f2a5bb475">PixelData2BitMap</a>(image.width(), image.height(), <a class="code" href="_emf_engine_plus_8cpp.html#fcec0a95fff23a495a52ea0cbb04abef">image2PixelData</a>(image, opacity));
<a name="l00118"></a>00118 }
<a name="l00119"></a>00119 
<a name="l00120"></a><a class="code" href="_emf_engine_plus_8cpp.html#4f23e9babc34eecba39c30793ac2e585">00120</a> <span class="keywordtype">wchar_t</span>* <a class="code" href="_emf_engine_8h.html#d98dd016146ece31dd7b1675ed61dfd0">qStringToWideChar</a>(<span class="keyword">const</span> QString&amp; s, <span class="keywordtype">int</span> *size)
<a name="l00121"></a>00121 {
<a name="l00122"></a>00122         <span class="keywordtype">int</span> length = s.length();
<a name="l00123"></a>00123         <span class="keywordtype">wchar_t</span> *ws = (<span class="keywordtype">wchar_t</span> *)malloc((length + 1)*<span class="keyword">sizeof</span>(wchar_t));
<a name="l00124"></a>00124         <span class="keywordflow">if</span> (!ws){
<a name="l00125"></a>00125                 qWarning(<span class="stringliteral">"EmfEngine: Not enough memory."</span>);
<a name="l00126"></a>00126                 <span class="keywordflow">if</span> (size)
<a name="l00127"></a>00127                         *size = -1;
<a name="l00128"></a>00128                 <span class="keywordflow">return</span> 0;
<a name="l00129"></a>00129         }
<a name="l00130"></a>00130         <span class="keywordtype">int</span> sz = s.toWCharArray(ws);
<a name="l00131"></a>00131         <span class="keywordflow">if</span> (size)
<a name="l00132"></a>00132                 *size = sz;
<a name="l00133"></a>00133         ws[length] = <span class="charliteral">'\0'</span>; <span class="comment">// Manually put terminating character</span>
<a name="l00134"></a>00134         <span class="keywordflow">return</span> ws;
<a name="l00135"></a>00135 }
<a name="l00136"></a>00136 
<a name="l00137"></a><a class="code" href="class_emf_paint_engine.html#4572104475ba96c7981cfcddbebdd836">00137</a> <a class="code" href="class_emf_paint_engine.html#4572104475ba96c7981cfcddbebdd836" title="Constructor used in order to copy the metafile to clipboard.">EmfPaintEngine::EmfPaintEngine</a>() : QPaintEngine(QPaintEngine::AllFeatures),
<a name="l00138"></a>00138 fname(<span class="stringliteral">""</span>),
<a name="l00139"></a>00139 d_mem_size(0)
<a name="l00140"></a>00140 {
<a name="l00141"></a>00141         init();
<a name="l00142"></a>00142 }
<a name="l00143"></a>00143 
<a name="l00144"></a><a class="code" href="class_emf_paint_engine.html#35f71ab56c1f46ef03ae8bf71c68dd08">00144</a> <a class="code" href="class_emf_paint_engine.html#4572104475ba96c7981cfcddbebdd836" title="Constructor used in order to copy the metafile to clipboard.">EmfPaintEngine::EmfPaintEngine</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> memSize) : QPaintEngine(QPaintEngine::AllFeatures),
<a name="l00145"></a>00145 d_mem_size(memSize)
<a name="l00146"></a>00146 {
<a name="l00147"></a>00147         init();
<a name="l00148"></a>00148 }
<a name="l00149"></a>00149 
<a name="l00150"></a><a class="code" href="class_emf_paint_engine.html#276276423b08cf6d1c35f1d6d9231348">00150</a> <a class="code" href="class_emf_paint_engine.html#4572104475ba96c7981cfcddbebdd836" title="Constructor used in order to copy the metafile to clipboard.">EmfPaintEngine::EmfPaintEngine</a>(<span class="keyword">const</span> QString&amp; f) : QPaintEngine(QPaintEngine::AllFeatures),
<a name="l00151"></a>00151 fname(f)
<a name="l00152"></a>00152 {
<a name="l00153"></a>00153         init();
<a name="l00154"></a>00154 }
<a name="l00155"></a>00155 
<a name="l00156"></a>00156 <span class="keywordtype">void</span> EmfPaintEngine::init()
<a name="l00157"></a>00157 {
<a name="l00158"></a>00158         stream = NULL;
<a name="l00159"></a>00159         mPrivateFontCollection = NULL;
<a name="l00160"></a>00160         hMetaFileResult = NULL;
<a name="l00161"></a>00161 }
<a name="l00162"></a>00162 
<a name="l00163"></a><a class="code" href="class_emf_paint_engine.html#d9d1f51a97c916b0e35eb923d200e0fd">00163</a> <span class="keywordtype">void</span> <a class="code" href="class_emf_paint_engine.html#d9d1f51a97c916b0e35eb923d200e0fd">EmfPaintEngine::setFontFiles</a>(<span class="keyword">const</span> QStringList &amp;fontFiles)
<a name="l00164"></a>00164 {
<a name="l00165"></a>00165         <span class="comment">// TODO: Need to add support for adding to an existing PrivateFontCollection.</span>
<a name="l00166"></a>00166         mFontFiles = fontFiles;
<a name="l00167"></a>00167 }
<a name="l00168"></a>00168 
<a name="l00169"></a><a class="code" href="class_emf_paint_engine.html#c019fdc3e69a472af443a530a6464135">00169</a> <span class="keywordtype">bool</span> <a class="code" href="class_emf_paint_engine.html#c019fdc3e69a472af443a530a6464135">EmfPaintEngine::begin</a>(QPaintDevice* p)
<a name="l00170"></a>00170 {
<a name="l00171"></a>00171         setPaintDevice(p);
<a name="l00172"></a>00172 
<a name="l00173"></a>00173         <span class="keywordflow">if</span> (!fname.isEmpty()){
<a name="l00174"></a>00174 <span class="preprocessor">        #ifdef QT_NO_STL</span>
<a name="l00175"></a>00175 <span class="preprocessor"></span>                <span class="keywordtype">wchar_t</span> *wfname = <a class="code" href="_emf_engine_8h.html#d98dd016146ece31dd7b1675ed61dfd0">qStringToWideChar</a>(fname);
<a name="l00176"></a>00176                 <span class="keywordflow">if</span> (!wfname)
<a name="l00177"></a>00177                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00178"></a>00178 <span class="preprocessor">        #endif</span>
<a name="l00179"></a>00179 <span class="preprocessor"></span>        }
<a name="l00180"></a>00180 
<a name="l00181"></a>00181         GdiplusStartup(&amp;gdiplusToken, &amp;gdiplusStartupInput, NULL);      <span class="comment">// Initialize GDI+.</span>
<a name="l00182"></a>00182 
<a name="l00183"></a>00183         <span class="keywordflow">if</span> (!mFontFiles.isEmpty()){
<a name="l00184"></a>00184                 mPrivateFontCollection = <span class="keyword">new</span> PrivateFontCollection();
<a name="l00185"></a>00185 
<a name="l00186"></a>00186                 <span class="keywordtype">int</span> filesCount = mFontFiles.size();
<a name="l00187"></a>00187                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; filesCount; i++){
<a name="l00188"></a>00188                         <span class="keywordtype">wchar_t</span> *wpath = <a class="code" href="_emf_engine_8h.html#d98dd016146ece31dd7b1675ed61dfd0">qStringToWideChar</a>(mFontFiles[i]);
<a name="l00189"></a>00189                         <span class="keywordflow">if</span> (!wpath)
<a name="l00190"></a>00190                                 <span class="keywordflow">continue</span>;
<a name="l00191"></a>00191                         mPrivateFontCollection-&gt;AddFontFile(wpath);
<a name="l00192"></a>00192                         free(wpath);
<a name="l00193"></a>00193                 }
<a name="l00194"></a>00194         }
<a name="l00195"></a>00195 
<a name="l00196"></a>00196         <span class="keywordflow">if</span> (!fname.isEmpty()){
<a name="l00197"></a>00197                 <span class="keywordflow">if</span> (fname.endsWith(<span class="stringliteral">".wmf"</span>, Qt::CaseInsensitive))
<a name="l00198"></a>00198                         metafile = <span class="keyword">new</span> Metafile(GetDC(NULL), RectF(0, 0, paintDevice()-&gt;width(), paintDevice()-&gt;height()), MetafileFrameUnitPixel);
<a name="l00199"></a>00199                 <span class="keywordflow">else</span> {
<a name="l00200"></a>00200 <span class="preprocessor">        #ifdef QT_NO_STL</span>
<a name="l00201"></a>00201 <span class="preprocessor"></span>                metafile = <span class="keyword">new</span> Metafile(wfname, GetDC(NULL), RectF(0, 0, paintDevice()-&gt;width(), paintDevice()-&gt;height()), MetafileFrameUnitPixel);
<a name="l00202"></a>00202                 free(wfname);
<a name="l00203"></a>00203 <span class="preprocessor">        #else</span>
<a name="l00204"></a>00204 <span class="preprocessor"></span>                metafile = <span class="keyword">new</span> Metafile(fname.toStdWString().c_str(), GetDC(NULL), RectF(0, 0, paintDevice()-&gt;width(), paintDevice()-&gt;height()), MetafileFrameUnitPixel);
<a name="l00205"></a>00205 <span class="preprocessor">        #endif</span>
<a name="l00206"></a>00206 <span class="preprocessor"></span>                }
<a name="l00207"></a>00207         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (d_mem_size){
<a name="l00208"></a>00208                 pMem = GlobalAlloc(GMEM_MOVEABLE, d_mem_size);
<a name="l00209"></a>00209                 HRESULT hr = CreateStreamOnHGlobal(pMem, TRUE, &amp;stream);
<a name="l00210"></a>00210                 <span class="keywordflow">if</span> (SUCCEEDED(hr))
<a name="l00211"></a>00211                         metafile = <span class="keyword">new</span> Metafile(stream, GetDC(NULL), RectF(0, 0, paintDevice()-&gt;width(), paintDevice()-&gt;height()), MetafileFrameUnitPixel);
<a name="l00212"></a>00212         } <span class="keywordflow">else</span>
<a name="l00213"></a>00213                 metafile = <span class="keyword">new</span> Metafile(GetDC(NULL), RectF(0, 0, paintDevice()-&gt;width(), paintDevice()-&gt;height()), MetafileFrameUnitPixel);
<a name="l00214"></a>00214 
<a name="l00215"></a>00215         d_grx = <span class="keyword">new</span> Graphics(metafile);
<a name="l00216"></a>00216         d_grx-&gt;SetCompositingQuality(CompositingQualityHighQuality);
<a name="l00217"></a>00217         d_grx-&gt;SetInterpolationMode(InterpolationModeHighQualityBicubic);
<a name="l00218"></a>00218 <span class="preprocessor">#ifdef HAVE_ANTIALIASED_TEXT</span>
<a name="l00219"></a>00219 <span class="preprocessor"></span>        d_grx-&gt;SetTextRenderingHint(TextRenderingHintAntiAlias);
<a name="l00220"></a>00220 <span class="preprocessor">#endif</span>
<a name="l00221"></a>00221 <span class="preprocessor"></span>
<a name="l00222"></a>00222         <span class="keywordflow">if</span> (metafile &amp;&amp; d_grx)
<a name="l00223"></a>00223                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00224"></a>00224 
<a name="l00225"></a>00225         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00226"></a>00226 }
<a name="l00227"></a>00227 
<a name="l00228"></a>00228 <span class="keywordtype">bool</span> EmfPaintEngine::convertToWmf()
<a name="l00229"></a>00229 {
<a name="l00230"></a>00230         hMetaFileResult = metafile-&gt;GetHENHMETAFILE();
<a name="l00231"></a>00231         <span class="comment">// Determine the size of the buffer that will receive the converted records</span>
<a name="l00232"></a>00232         UINT size = Metafile::EmfToWmfBits(hMetaFileResult, 0, NULL, MM_ANISOTROPIC, EmfToWmfBitsFlagsEmbedEmf);
<a name="l00233"></a>00233         BYTE* buffer = <span class="keyword">new</span> BYTE[size];<span class="comment">// Allocate a buffer to receive the converted records</span>
<a name="l00234"></a>00234         <span class="comment">// Convert the EMF records to WMF records</span>
<a name="l00235"></a>00235         Metafile::EmfToWmfBits(hMetaFileResult, size, buffer, MM_ANISOTROPIC, EmfToWmfBitsFlagsEmbedEmf);
<a name="l00236"></a>00236         <span class="comment">//DeleteEnhMetaFile(hMetaFileResult);</span>
<a name="l00237"></a>00237         HMETAFILE hmf = SetMetaFileBitsEx(size, buffer);<span class="comment">// Get a handle to the converted metafile.</span>
<a name="l00238"></a>00238         <span class="keywordflow">if</span> (!hmf)
<a name="l00239"></a>00239                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00240"></a>00240 
<a name="l00241"></a>00241         freeMemory();
<a name="l00242"></a>00242 
<a name="l00243"></a>00243 <span class="preprocessor">#ifdef QT_NO_STL</span>
<a name="l00244"></a>00244 <span class="preprocessor"></span>        <span class="keywordtype">wchar_t</span> *wfname = <a class="code" href="_emf_engine_8h.html#d98dd016146ece31dd7b1675ed61dfd0">qStringToWideChar</a>(fname);
<a name="l00245"></a>00245         <span class="keywordflow">if</span> (!wfname)
<a name="l00246"></a>00246                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00247"></a>00247         <span class="keywordflow">if</span> (CopyMetaFile(hmf, wfname) != NULL){
<a name="l00248"></a>00248 <span class="preprocessor">#else</span>
<a name="l00249"></a>00249 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (CopyMetaFile(hmf, fname.toStdWString().c_str()) != NULL){
<a name="l00250"></a>00250 <span class="preprocessor">#endif</span>
<a name="l00251"></a>00251 <span class="preprocessor"></span>                DeleteMetaFile(hmf);
<a name="l00252"></a>00252                 <span class="keyword">delete</span>[] buffer;
<a name="l00253"></a>00253                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00254"></a>00254         }
<a name="l00255"></a>00255         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00256"></a>00256 }
<a name="l00257"></a>00257 
<a name="l00258"></a><a class="code" href="class_emf_paint_engine.html#9a923d5311faf89f1a1e59ae39c0bbf2">00258</a> <span class="keywordtype">bool</span> <a class="code" href="class_emf_paint_engine.html#9a923d5311faf89f1a1e59ae39c0bbf2">EmfPaintEngine::copyToClipboard</a>()
<a name="l00259"></a>00259 {
<a name="l00260"></a>00260         <span class="keywordflow">if</span> (OpenClipboard(0)){
<a name="l00261"></a>00261                 EmptyClipboard();
<a name="l00262"></a>00262                 SetClipboardData(CF_ENHMETAFILE, hMetaFileResult);
<a name="l00263"></a>00263                 CloseClipboard();
<a name="l00264"></a>00264                 freeMemory();
<a name="l00265"></a>00265                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00266"></a>00266         }
<a name="l00267"></a>00267 
<a name="l00268"></a>00268         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00269"></a>00269 }
<a name="l00270"></a>00270 
<a name="l00271"></a><a class="code" href="class_emf_paint_engine.html#121bcc1139d6a38294d27e210aff5708">00271</a> <span class="keywordtype">bool</span> <a class="code" href="class_emf_paint_engine.html#121bcc1139d6a38294d27e210aff5708">EmfPaintEngine::end</a>()
<a name="l00272"></a>00272 {
<a name="l00273"></a>00273         <span class="keyword">delete</span> d_grx;
<a name="l00274"></a>00274 
<a name="l00275"></a>00275         MetafileHeader metaHeader;
<a name="l00276"></a>00276         metafile-&gt;GetMetafileHeader(&amp;metaHeader);
<a name="l00277"></a>00277         d_metafile_size = metaHeader.GetMetafileSize();
<a name="l00278"></a>00278 
<a name="l00279"></a>00279         <span class="keywordflow">if</span> (fname.isEmpty()){
<a name="l00280"></a>00280                 hMetaFileResult = metafile-&gt;GetHENHMETAFILE();
<a name="l00281"></a>00281                 <span class="keywordflow">if</span> (!stream)
<a name="l00282"></a>00282                         <span class="keywordflow">return</span> <a class="code" href="class_emf_paint_engine.html#9a923d5311faf89f1a1e59ae39c0bbf2">copyToClipboard</a>();
<a name="l00283"></a>00283         }
<a name="l00284"></a>00284 
<a name="l00285"></a>00285         <span class="keywordflow">if</span> (fname.endsWith(<span class="stringliteral">".wmf"</span>, Qt::CaseInsensitive))
<a name="l00286"></a>00286                 <span class="keywordflow">return</span> convertToWmf();
<a name="l00287"></a>00287 
<a name="l00288"></a>00288         <span class="keywordflow">if</span> (stream)
<a name="l00289"></a>00289                 writeToByteArray();
<a name="l00290"></a>00290 
<a name="l00291"></a>00291         freeMemory();
<a name="l00292"></a>00292         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00293"></a>00293 }
<a name="l00294"></a>00294 
<a name="l00295"></a>00295 <span class="keywordtype">void</span> EmfPaintEngine::freeMemory()
<a name="l00296"></a>00296 {
<a name="l00297"></a>00297         <span class="keyword">delete</span> metafile;
<a name="l00298"></a>00298 
<a name="l00299"></a>00299         <span class="keywordflow">if</span> (mPrivateFontCollection)
<a name="l00300"></a>00300                 <span class="keyword">delete</span> mPrivateFontCollection;
<a name="l00301"></a>00301 
<a name="l00302"></a>00302         GdiplusShutdown(gdiplusToken);
<a name="l00303"></a>00303 }
<a name="l00304"></a>00304 
<a name="l00305"></a>00305 <span class="keywordtype">void</span> EmfPaintEngine::writeToByteArray()
<a name="l00306"></a>00306 {
<a name="l00307"></a>00307         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ul;
<a name="l00308"></a>00308         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> size = 1024;
<a name="l00309"></a>00309         <span class="keywordtype">char</span> buf[size];
<a name="l00310"></a>00310 
<a name="l00311"></a>00311         <span class="comment">// reset the stream pointer to the front</span>
<a name="l00312"></a>00312         LARGE_INTEGER lSeek = {0};
<a name="l00313"></a>00313         stream-&gt;Seek(lSeek, STREAM_SEEK_SET, NULL);
<a name="l00314"></a>00314 
<a name="l00315"></a>00315         QBuffer buffer(&amp;d_byteArray);
<a name="l00316"></a>00316         buffer.open(QIODevice::WriteOnly);
<a name="l00317"></a>00317         <span class="keywordflow">do</span> {
<a name="l00318"></a>00318                 HRESULT hr = stream-&gt;Read(buf, size, &amp;ul);
<a name="l00319"></a>00319                 <span class="keywordflow">if</span> (SUCCEEDED(hr)){
<a name="l00320"></a>00320                         <span class="keywordtype">int</span> arraySize = d_byteArray.size();
<a name="l00321"></a>00321                         <span class="keywordflow">if</span> (arraySize + ul &lt; d_metafile_size)
<a name="l00322"></a>00322                                 buffer.write(buf, ul);
<a name="l00323"></a>00323                         <span class="keywordflow">else</span> {
<a name="l00324"></a>00324                                 buffer.write(buf, d_metafile_size - arraySize);
<a name="l00325"></a>00325                                 <span class="keywordflow">break</span>;
<a name="l00326"></a>00326                         }
<a name="l00327"></a>00327                 } <span class="keywordflow">else</span>
<a name="l00328"></a>00328                         <span class="keywordflow">break</span>;
<a name="l00329"></a>00329         } <span class="keywordflow">while</span> (ul &gt; 0);
<a name="l00330"></a>00330 
<a name="l00331"></a>00331         GlobalFree(pMem);
<a name="l00332"></a>00332 }
<a name="l00333"></a>00333 
<a name="l00334"></a><a class="code" href="class_emf_paint_engine.html#61088d087223769ebe72dde2eef5edee">00334</a> <span class="keywordtype">void</span> <a class="code" href="class_emf_paint_engine.html#61088d087223769ebe72dde2eef5edee">EmfPaintEngine::drawPoints</a>(<span class="keyword">const</span> QPointF * points, <span class="keywordtype">int</span> pointCount)
<a name="l00335"></a>00335 {
<a name="l00336"></a>00336         setClipping();
<a name="l00337"></a>00337 
<a name="l00338"></a>00338         QPen pen = painter()-&gt;pen();
<a name="l00339"></a>00339         REAL lw = pen.widthF();
<a name="l00340"></a>00340         QColor color = pen.color();
<a name="l00341"></a>00341         SolidBrush *br = <span class="keyword">new</span> SolidBrush(Color(color.alpha(), color.red(), color.green(), color.blue()));
<a name="l00342"></a>00342 
<a name="l00343"></a>00343         QTransform m = painter()-&gt;combinedTransform();
<a name="l00344"></a>00344         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; pointCount; i++) {
<a name="l00345"></a>00345                 QPointF p = m.map(points[i]);
<a name="l00346"></a>00346                 d_grx-&gt;FillRectangle(br, RectF(p.x(), p.y(), lw, lw));
<a name="l00347"></a>00347         }
<a name="l00348"></a>00348 
<a name="l00349"></a>00349         <span class="keyword">delete</span> br;
<a name="l00350"></a>00350         resetClipping();
<a name="l00351"></a>00351 }
<a name="l00352"></a>00352 
<a name="l00353"></a><a class="code" href="class_emf_paint_engine.html#7e5fb1bbd2aecec60e61c271e9c00f27">00353</a> <span class="keywordtype">void</span> <a class="code" href="class_emf_paint_engine.html#7e5fb1bbd2aecec60e61c271e9c00f27">EmfPaintEngine::drawLines</a>(<span class="keyword">const</span> QLineF * lines, <span class="keywordtype">int</span> lineCount)
<a name="l00354"></a>00354 {
<a name="l00355"></a>00355         setClipping();
<a name="l00356"></a>00356 
<a name="l00357"></a>00357         Pen *pen = convertPen(painter());
<a name="l00358"></a>00358 
<a name="l00359"></a>00359         QTransform m = painter()-&gt;combinedTransform();
<a name="l00360"></a>00360         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; lineCount; i++){
<a name="l00361"></a>00361                 QPointF p1 = m.map(lines[i].p1());
<a name="l00362"></a>00362                 QPointF p2 = m.map(lines[i].p2());
<a name="l00363"></a>00363 
<a name="l00364"></a>00364                 PointF wp1(p1.x(), p1.y());
<a name="l00365"></a>00365                 PointF wp2(p2.x(), p2.y());
<a name="l00366"></a>00366 
<a name="l00367"></a>00367                 d_grx-&gt;DrawLine(pen, wp1, wp2);
<a name="l00368"></a>00368         }
<a name="l00369"></a>00369 
<a name="l00370"></a>00370         <span class="keyword">delete</span> pen;
<a name="l00371"></a>00371         resetClipping();
<a name="l00372"></a>00372 }
<a name="l00373"></a>00373 
<a name="l00374"></a><a class="code" href="class_emf_paint_engine.html#bc7678b162d08a14a24b0177c97cf9d3">00374</a> <span class="keywordtype">void</span> <a class="code" href="class_emf_paint_engine.html#bc7678b162d08a14a24b0177c97cf9d3">EmfPaintEngine::drawPolygon</a>(<span class="keyword">const</span> QPointF * points, <span class="keywordtype">int</span> pointCount, PolygonDrawMode mode)
<a name="l00375"></a>00375 {
<a name="l00376"></a>00376         setClipping();
<a name="l00377"></a>00377 
<a name="l00378"></a>00378         PointF *pts = <span class="keyword">new</span> PointF[pointCount];
<a name="l00379"></a>00379 
<a name="l00380"></a>00380         QTransform m = painter()-&gt;combinedTransform();
<a name="l00381"></a>00381         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; pointCount; i++){
<a name="l00382"></a>00382                 QPointF p = m.map (points[i]);
<a name="l00383"></a>00383                 pts[i] = PointF(p.x(), p.y());
<a name="l00384"></a>00384         }
<a name="l00385"></a>00385 
<a name="l00386"></a>00386         Pen *pen = convertPen(painter());
<a name="l00387"></a>00387         Qt::BrushStyle brushStyle = painter()-&gt;brush().style();
<a name="l00388"></a>00388 
<a name="l00389"></a>00389         <span class="keywordflow">if</span> (mode == QPaintEngine::PolylineMode)
<a name="l00390"></a>00390                 d_grx-&gt;DrawLines(pen, pts, pointCount);
<a name="l00391"></a>00391         <span class="keywordflow">else</span> {
<a name="l00392"></a>00392                 <span class="keywordflow">if</span> (brushStyle != Qt::NoBrush){
<a name="l00393"></a>00393                         GraphicsPath path;
<a name="l00394"></a>00394                         path.AddPolygon(pts, pointCount);
<a name="l00395"></a>00395 
<a name="l00396"></a>00396                         Brush *brush = convertBrush(painter()-&gt;brush(), &amp;path);
<a name="l00397"></a>00397                         <span class="keywordflow">if</span> (mode == QPaintEngine::OddEvenMode)
<a name="l00398"></a>00398                                 d_grx-&gt;FillPolygon(brush, pts, pointCount, FillModeAlternate);
<a name="l00399"></a>00399                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mode == QPaintEngine::WindingMode)
<a name="l00400"></a>00400                                 d_grx-&gt;FillPolygon(brush, pts, pointCount, FillModeWinding);
<a name="l00401"></a>00401                         <span class="keywordflow">else</span>
<a name="l00402"></a>00402                                 d_grx-&gt;FillPolygon(brush, pts, pointCount);
<a name="l00403"></a>00403                         <span class="keyword">delete</span> brush;
<a name="l00404"></a>00404                 }
<a name="l00405"></a>00405                 d_grx-&gt;DrawPolygon(pen, pts, pointCount);
<a name="l00406"></a>00406         }
<a name="l00407"></a>00407 
<a name="l00408"></a>00408         <span class="keyword">delete</span> pen;
<a name="l00409"></a>00409         <span class="keyword">delete</span> [] pts;
<a name="l00410"></a>00410         resetClipping();
<a name="l00411"></a>00411 }
<a name="l00412"></a>00412 
<a name="l00413"></a>00413 FontFamily *EmfPaintEngine::getFontFamily(<span class="keyword">const</span> QString &amp;family)
<a name="l00414"></a>00414 {
<a name="l00415"></a>00415         FontFamily *fontFamily = NULL;
<a name="l00416"></a>00416 
<a name="l00417"></a>00417         <span class="keywordtype">wchar_t</span> *wfamily = <a class="code" href="_emf_engine_8h.html#d98dd016146ece31dd7b1675ed61dfd0">qStringToWideChar</a>(family);
<a name="l00418"></a>00418         <span class="keywordflow">if</span> (wfamily){
<a name="l00419"></a>00419                 <span class="keywordflow">if</span> (mPrivateFontCollection){
<a name="l00420"></a>00420                         fontFamily = <span class="keyword">new</span> FontFamily(wfamily, mPrivateFontCollection);
<a name="l00421"></a>00421                         <span class="keywordflow">if</span> (!fontFamily-&gt;IsAvailable()){
<a name="l00422"></a>00422                                 <span class="keyword">delete</span> fontFamily;
<a name="l00423"></a>00423                                 fontFamily = NULL;
<a name="l00424"></a>00424                         }
<a name="l00425"></a>00425                 }
<a name="l00426"></a>00426 
<a name="l00427"></a>00427                 <span class="keywordflow">if</span> (!fontFamily)
<a name="l00428"></a>00428                         fontFamily = <span class="keyword">new</span> FontFamily(wfamily);
<a name="l00429"></a>00429 
<a name="l00430"></a>00430                 free(wfamily);
<a name="l00431"></a>00431         } <span class="keywordflow">else</span>
<a name="l00432"></a>00432                 fontFamily = <span class="keyword">new</span> FontFamily();
<a name="l00433"></a>00433 
<a name="l00434"></a>00434         <span class="keywordflow">return</span> fontFamily;
<a name="l00435"></a>00435 }
<a name="l00436"></a>00436 
<a name="l00437"></a><a class="code" href="class_emf_paint_engine.html#d5d5cd3c75995f261722c746bac96b0a">00437</a> <span class="keywordtype">void</span> <a class="code" href="class_emf_paint_engine.html#d5d5cd3c75995f261722c746bac96b0a">EmfPaintEngine::drawTextItem</a>(<span class="keyword">const</span> QPointF &amp; p, <span class="keyword">const</span> QTextItem &amp; textItem)
<a name="l00438"></a>00438 {
<a name="l00439"></a>00439         QFont f = textItem.font();
<a name="l00440"></a>00440 
<a name="l00441"></a>00441         <span class="comment">// Use the QFontInfo to determine the font to use. It will return</span>
<a name="l00442"></a>00442         <span class="comment">// the font that Qt will use (in cases where the font specified by the user doesn't exist).</span>
<a name="l00443"></a>00443         QFontInfo fontInfo(f);
<a name="l00444"></a>00444         QString family = fontInfo.family();
<a name="l00445"></a>00445 
<a name="l00446"></a>00446         FontFamily *fontFamily = getFontFamily(family);
<a name="l00447"></a>00447         <span class="keywordflow">if</span> (!fontFamily-&gt;IsAvailable()){
<a name="l00448"></a>00448                 qWarning(<span class="stringliteral">"EmfEngine::drawTextItem(): font family '%s' is not available."</span>, family.toLatin1().constData());
<a name="l00449"></a>00449 
<a name="l00450"></a>00450                 <span class="keywordflow">if</span> (fontFamily){
<a name="l00451"></a>00451                         <span class="keyword">delete</span> fontFamily;
<a name="l00452"></a>00452                         fontFamily = 0;
<a name="l00453"></a>00453                 }
<a name="l00454"></a>00454 
<a name="l00455"></a>00455                 InstalledFontCollection installedFontCollection;
<a name="l00456"></a>00456                 <span class="keywordtype">int</span> count = installedFontCollection.GetFamilyCount();
<a name="l00457"></a>00457                 <span class="keywordflow">if</span> (!count)
<a name="l00458"></a>00458                         <span class="keywordflow">return</span>;
<a name="l00459"></a>00459 
<a name="l00460"></a>00460                 FontFamily *pFontFamily = <span class="keyword">new</span> FontFamily[count];
<a name="l00461"></a>00461                 <span class="keywordtype">int</span> found = 0;
<a name="l00462"></a>00462                 installedFontCollection.GetFamilies(count, pFontFamily, &amp;found);
<a name="l00463"></a>00463                 <span class="keywordflow">if</span> (!found){
<a name="l00464"></a>00464                         <span class="keyword">delete</span> [] pFontFamily;
<a name="l00465"></a>00465                         <span class="keywordflow">return</span>;
<a name="l00466"></a>00466                 }
<a name="l00467"></a>00467 
<a name="l00468"></a>00468                 WCHAR familyName[LF_FACESIZE];
<a name="l00469"></a>00469                 pFontFamily-&gt;GetFamilyName(familyName);
<a name="l00470"></a>00470 
<a name="l00471"></a>00471                 fontFamily = <span class="keyword">new</span> FontFamily(familyName);
<a name="l00472"></a>00472 
<a name="l00473"></a>00473                 qWarning(<span class="stringliteral">"Font replaced with: '%ls'"</span>, familyName);
<a name="l00474"></a>00474                 <span class="keyword">delete</span> [] pFontFamily;
<a name="l00475"></a>00475         }
<a name="l00476"></a>00476 
<a name="l00477"></a>00477         INT fontStyle = FontStyleRegular;
<a name="l00478"></a>00478         <span class="keywordflow">if</span> (f.italic())
<a name="l00479"></a>00479                 fontStyle = fontStyle | FontStyleItalic;
<a name="l00480"></a>00480         <span class="keywordflow">if</span> (f.bold())
<a name="l00481"></a>00481                 fontStyle = fontStyle | FontStyleBold;
<a name="l00482"></a>00482 
<a name="l00483"></a>00483         <span class="comment">// The underline/strikeout rendering is done by Qt internally.</span>
<a name="l00484"></a>00484         <span class="comment">// QPainter::drawTextItem  performs an additional rendering call after calling drawTextItem() on the engine object, see:</span>
<a name="l00485"></a>00485         <span class="comment">// drawTextItemDecoration(this, p, ti.fontEngine, ti.underlineStyle, ti.flags, ti.width.toReal(), ti.charFormat);</span>
<a name="l00486"></a>00486         <span class="comment">/*if (f.underline())</span>
<a name="l00487"></a>00487 <span class="comment">                fontStyle = fontStyle | FontStyleUnderline;</span>
<a name="l00488"></a>00488 <span class="comment">        if (f.strikeOut())</span>
<a name="l00489"></a>00489 <span class="comment">                fontStyle = fontStyle | FontStyleStrikeout;*/</span>
<a name="l00490"></a>00490 
<a name="l00491"></a>00491         QString text = textItem.text();
<a name="l00492"></a>00492         <span class="keywordtype">int</span> size = text.size();
<a name="l00493"></a>00493         <span class="keywordtype">wchar_t</span> *wtext = <a class="code" href="_emf_engine_8h.html#d98dd016146ece31dd7b1675ed61dfd0">qStringToWideChar</a>(text, &amp;size);
<a name="l00494"></a>00494         <span class="keywordflow">if</span> (!wtext)
<a name="l00495"></a>00495                 <span class="keywordflow">return</span>;
<a name="l00496"></a>00496 
<a name="l00497"></a>00497         setClipping();
<a name="l00498"></a>00498 
<a name="l00499"></a>00499         QColor c = painter()-&gt;pen().color();
<a name="l00500"></a>00500         SolidBrush brush(Color(c.alpha(), c.red(), c.green(), c.blue()));
<a name="l00501"></a>00501 
<a name="l00502"></a>00502         Gdiplus::Matrix *m = convertTransform(painter()-&gt;combinedTransform());
<a name="l00503"></a>00503         d_grx-&gt;SetTransform(m);
<a name="l00504"></a>00504         <span class="keyword">delete</span> m;
<a name="l00505"></a>00505 
<a name="l00506"></a>00506         <span class="keywordtype">int</span> height = QFontMetrics(f).boundingRect(text).height();
<a name="l00507"></a>00507         <span class="keywordtype">double</span> textWidth = textItem.width();
<a name="l00508"></a>00508         PointF origin = PointF(p.x(), p.y() - 0.75*height);
<a name="l00509"></a>00509         RectF layoutRect = RectF(origin.X, origin.Y, textWidth, height);
<a name="l00510"></a>00510 
<a name="l00511"></a>00511         StringFormat format;
<a name="l00512"></a>00512         format.SetFormatFlags(StringFormatFlagsNoWrap|StringFormatFlagsNoFitBlackBox|StringFormatFlagsNoClip|StringFormatFlagsMeasureTrailingSpaces);
<a name="l00513"></a>00513         format.SetAlignment(StringAlignmentCenter);
<a name="l00514"></a>00514         format.SetLineAlignment(StringAlignmentNear);
<a name="l00515"></a>00515         format.SetTrimming(StringTrimmingNone);
<a name="l00516"></a>00516         format.SetTabStops(0, 0, 0);
<a name="l00517"></a>00517 
<a name="l00518"></a>00518         CharacterRange charRanges[1] = {CharacterRange(0, size)};
<a name="l00519"></a>00519         format.SetMeasurableCharacterRanges(1, charRanges);
<a name="l00520"></a>00520 
<a name="l00521"></a>00521         Region *pCharRangeRegion = <span class="keyword">new</span> Region;
<a name="l00522"></a>00522 
<a name="l00523"></a>00523         <span class="keywordtype">double</span> fontSize = f.pointSizeF();
<a name="l00524"></a>00524         <span class="keywordtype">bool</span> pointsFont = (fontSize != -1);
<a name="l00525"></a>00525 <span class="preprocessor">        #ifndef HAVE_FIXED_FONT_SIZE</span>
<a name="l00526"></a>00526 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (pointsFont){
<a name="l00527"></a>00527                 RectF boundRect = RectF(origin.X, origin.Y, textWidth, height);
<a name="l00528"></a>00528                 <span class="keywordflow">if</span> (boundRect.Width &gt;= textWidth){
<a name="l00529"></a>00529                         <span class="keywordtype">double</span> fUpperFontSize = fontSize;
<a name="l00530"></a>00530                         <span class="keywordtype">double</span> fLowerFontSize = 1.0f;
<a name="l00531"></a>00531                         <span class="keywordtype">double</span> fCurrentFontSize = 0.5*(fUpperFontSize + fLowerFontSize);
<a name="l00532"></a>00532                         <span class="keywordflow">while</span> (fUpperFontSize - fLowerFontSize &gt; 0.01f){
<a name="l00533"></a>00533                                 Font font(fontFamily, fCurrentFontSize, fontStyle, UnitPoint);
<a name="l00534"></a>00534                                 d_grx-&gt;MeasureCharacterRanges(wtext, -1, &amp;font, layoutRect, &amp;format, 1, pCharRangeRegion);
<a name="l00535"></a>00535                                 pCharRangeRegion-&gt;GetBounds(&amp;boundRect, d_grx);
<a name="l00536"></a>00536 
<a name="l00537"></a>00537                                 <span class="keywordflow">if</span> (boundRect.Width &gt;= textWidth)
<a name="l00538"></a>00538                                         fUpperFontSize = fCurrentFontSize;
<a name="l00539"></a>00539                                 <span class="keywordflow">else</span>
<a name="l00540"></a>00540                                         fLowerFontSize = fCurrentFontSize;
<a name="l00541"></a>00541 
<a name="l00542"></a>00542                                 fCurrentFontSize = 0.5*(fUpperFontSize + fLowerFontSize);
<a name="l00543"></a>00543                         }
<a name="l00544"></a>00544                         fontSize = fCurrentFontSize;
<a name="l00545"></a>00545                 }
<a name="l00546"></a>00546                 <span class="comment">//qWarning("Output font size is: %.2f instead of: %.2f", fontSize, f.pointSizeF());</span>
<a name="l00547"></a>00547         }
<a name="l00548"></a>00548 <span class="preprocessor">        #endif</span>
<a name="l00549"></a>00549 <span class="preprocessor"></span>
<a name="l00550"></a>00550         Font *font = pointsFont ? <span class="keyword">new</span> Font(fontFamily, <span class="keywordtype">double</span>(fontSize), fontStyle, UnitPoint) :
<a name="l00551"></a>00551                                                           <span class="keyword">new</span> Font(fontFamily, <span class="keywordtype">double</span>(f.pixelSize()), fontStyle, UnitPixel);
<a name="l00552"></a>00552 
<a name="l00553"></a>00553         d_grx-&gt;MeasureCharacterRanges(wtext, -1, font, layoutRect, &amp;format, 1, pCharRangeRegion);
<a name="l00554"></a>00554         pCharRangeRegion-&gt;GetBounds(&amp;layoutRect, d_grx);
<a name="l00555"></a>00555         <span class="keyword">delete</span> pCharRangeRegion;
<a name="l00556"></a>00556 
<a name="l00557"></a>00557         d_grx-&gt;DrawString(wtext, size, font, layoutRect, &amp;format, &amp;brush);
<a name="l00558"></a>00558         free(wtext);
<a name="l00559"></a>00559 
<a name="l00560"></a>00560         d_grx-&gt;ResetTransform();
<a name="l00561"></a>00561 
<a name="l00562"></a>00562         <span class="keyword">delete</span> font;
<a name="l00563"></a>00563         <span class="keyword">delete</span> fontFamily;
<a name="l00564"></a>00564 
<a name="l00565"></a>00565         resetClipping();
<a name="l00566"></a>00566 }
<a name="l00567"></a>00567 
<a name="l00568"></a><a class="code" href="class_emf_paint_engine.html#3019bb2f4d5b46c835aac8859a6dd739">00568</a> <span class="keywordtype">void</span> <a class="code" href="class_emf_paint_engine.html#3019bb2f4d5b46c835aac8859a6dd739">EmfPaintEngine::drawRects</a>(<span class="keyword">const</span> QRectF * rects, <span class="keywordtype">int</span> rectCount)
<a name="l00569"></a>00569 {
<a name="l00570"></a>00570         setClipping();
<a name="l00571"></a>00571 
<a name="l00572"></a>00572         Pen *pen = convertPen(painter());
<a name="l00573"></a>00573         Qt::BrushStyle brushStyle = painter()-&gt;brush().style();
<a name="l00574"></a>00574 
<a name="l00575"></a>00575         QTransform m = painter()-&gt;combinedTransform();
<a name="l00576"></a>00576         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; rectCount; i++){
<a name="l00577"></a>00577                 PointF *pts = <span class="keyword">new</span> PointF[4];
<a name="l00578"></a>00578 
<a name="l00579"></a>00579                 QPolygonF poly(rects[i]);
<a name="l00580"></a>00580                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; 4; j++){
<a name="l00581"></a>00581                         QPointF p = m.map(poly[j]);
<a name="l00582"></a>00582                         pts[j] = PointF(p.x(), p.y());
<a name="l00583"></a>00583                 }
<a name="l00584"></a>00584 
<a name="l00585"></a>00585                 GraphicsPath path;
<a name="l00586"></a>00586                 path.AddPolygon(pts, 4);
<a name="l00587"></a>00587 
<a name="l00588"></a>00588                 <span class="keywordflow">if</span> (brushStyle != Qt::NoBrush){
<a name="l00589"></a>00589                         Brush *brush = convertBrush(painter()-&gt;brush(), &amp;path);
<a name="l00590"></a>00590                         d_grx-&gt;FillPath(brush, &amp;path);
<a name="l00591"></a>00591                         <span class="keyword">delete</span> brush;
<a name="l00592"></a>00592                 }
<a name="l00593"></a>00593 
<a name="l00594"></a>00594                 d_grx-&gt;DrawPath(pen, &amp;path);
<a name="l00595"></a>00595                 <span class="keyword">delete</span> [] pts;
<a name="l00596"></a>00596         }
<a name="l00597"></a>00597 
<a name="l00598"></a>00598         resetClipping();
<a name="l00599"></a>00599         <span class="keyword">delete</span> pen;
<a name="l00600"></a>00600 }
<a name="l00601"></a>00601 
<a name="l00602"></a><a class="code" href="class_emf_paint_engine.html#b44252b7496c716f90a1d8e64d5f103a">00602</a> <span class="keywordtype">void</span> <a class="code" href="class_emf_paint_engine.html#b44252b7496c716f90a1d8e64d5f103a">EmfPaintEngine::drawEllipse</a>(<span class="keyword">const</span> QRectF &amp; rect)
<a name="l00603"></a>00603 {
<a name="l00604"></a>00604         setClipping();
<a name="l00605"></a>00605 
<a name="l00606"></a>00606         QRectF r = painter()-&gt;combinedTransform().mapRect(rect);
<a name="l00607"></a>00607         RectF rf((REAL)r.left(), (REAL)r.top(), (REAL)r.width(), (REAL)r.height());
<a name="l00608"></a>00608 
<a name="l00609"></a>00609         <span class="keywordflow">if</span> (painter()-&gt;brush().style() != Qt::NoBrush){
<a name="l00610"></a>00610                 Brush *brush = convertBrush(painter()-&gt;brush());
<a name="l00611"></a>00611                 d_grx-&gt;FillEllipse(brush, rf);
<a name="l00612"></a>00612                 <span class="keyword">delete</span> brush;
<a name="l00613"></a>00613         }
<a name="l00614"></a>00614 
<a name="l00615"></a>00615         Pen *pen = convertPen(painter());
<a name="l00616"></a>00616         d_grx-&gt;DrawEllipse(pen, rf);
<a name="l00617"></a>00617         <span class="keyword">delete</span> pen;
<a name="l00618"></a>00618 
<a name="l00619"></a>00619         resetClipping();
<a name="l00620"></a>00620 }
<a name="l00621"></a>00621 
<a name="l00622"></a><a class="code" href="class_emf_paint_engine.html#441c599b89751bca520a76a7f0b60c3a">00622</a> <span class="keywordtype">void</span> <a class="code" href="class_emf_paint_engine.html#441c599b89751bca520a76a7f0b60c3a">EmfPaintEngine::drawPath</a>(<span class="keyword">const</span> QPainterPath&amp; path)
<a name="l00623"></a>00623 {
<a name="l00624"></a>00624         setClipping();
<a name="l00625"></a>00625 
<a name="l00626"></a>00626         GraphicsPath *wpath = convertPath(path);
<a name="l00627"></a>00627         <span class="keywordflow">if</span> (!wpath)
<a name="l00628"></a>00628                 <span class="keywordflow">return</span>;
<a name="l00629"></a>00629 
<a name="l00630"></a>00630         <span class="keywordflow">if</span> (painter()-&gt;brush().style() != Qt::NoBrush){
<a name="l00631"></a>00631                 Brush *brush = convertBrush(painter()-&gt;brush(), wpath);
<a name="l00632"></a>00632                 d_grx-&gt;FillPath(brush, wpath);
<a name="l00633"></a>00633                 <span class="keyword">delete</span> brush;
<a name="l00634"></a>00634         }
<a name="l00635"></a>00635 
<a name="l00636"></a>00636         Pen *pen = convertPen(painter());
<a name="l00637"></a>00637         d_grx-&gt;DrawPath(pen, wpath);
<a name="l00638"></a>00638         <span class="keyword">delete</span> pen;
<a name="l00639"></a>00639 
<a name="l00640"></a>00640         <span class="keyword">delete</span> wpath;
<a name="l00641"></a>00641         resetClipping();
<a name="l00642"></a>00642 }
<a name="l00643"></a>00643 
<a name="l00644"></a><a class="code" href="class_emf_paint_engine.html#a35f167a09b015d9e9805d9aaf1777ae">00644</a> <span class="keywordtype">void</span> <a class="code" href="class_emf_paint_engine.html#a35f167a09b015d9e9805d9aaf1777ae">EmfPaintEngine::drawPixmap</a>(<span class="keyword">const</span> QRectF &amp;r, <span class="keyword">const</span> QPixmap &amp;pm, <span class="keyword">const</span> QRectF &amp;sr)
<a name="l00645"></a>00645 {
<a name="l00646"></a>00646         setClipping();
<a name="l00647"></a>00647 
<a name="l00648"></a>00648         QTransform m = painter()-&gt;combinedTransform();
<a name="l00649"></a>00649         QPolygonF poly = m.map(QPolygonF() &lt;&lt; r.topLeft() &lt;&lt; r.topRight() &lt;&lt; r.bottomRight() &lt;&lt; r.bottomLeft());
<a name="l00650"></a>00650 
<a name="l00651"></a>00651         PointF destPoints[] = {
<a name="l00652"></a>00652                 PointF(poly.at(0).x(), poly.at(0).y()), <span class="comment">// destination for upper-left point of original</span>
<a name="l00653"></a>00653                 PointF(poly.at(1).x(), poly.at(1).y()), <span class="comment">// destination for upper-right point of original</span>
<a name="l00654"></a>00654                 PointF(poly.at(3).x(), poly.at(3).y())};<span class="comment">// destination for lower-left point of original</span>
<a name="l00655"></a>00655 
<a name="l00656"></a>00656         Bitmap *bm = <a class="code" href="_emf_engine_plus_8cpp.html#2cd7d484029373b8c70e7e1dc161fcae">pixToBitmap</a>(pm.copy(sr.toAlignedRect()), painter()-&gt;opacity());
<a name="l00657"></a>00657         d_grx-&gt;DrawImage(bm, destPoints, 3);
<a name="l00658"></a>00658         <span class="keyword">delete</span> bm;
<a name="l00659"></a>00659 
<a name="l00660"></a>00660         resetClipping();
<a name="l00661"></a>00661 }
<a name="l00662"></a>00662 
<a name="l00663"></a><a class="code" href="class_emf_paint_engine.html#1e87e9dc8d6e150276566206b8bbfe02">00663</a> <span class="keywordtype">void</span> <a class="code" href="class_emf_paint_engine.html#1e87e9dc8d6e150276566206b8bbfe02">EmfPaintEngine::drawTiledPixmap</a>(<span class="keyword">const</span> QRectF&amp; r, <span class="keyword">const</span> QPixmap&amp; pix, <span class="keyword">const</span> QPointF&amp; p)
<a name="l00664"></a>00664 {
<a name="l00665"></a>00665         setClipping();
<a name="l00666"></a>00666 
<a name="l00667"></a>00667         QTransform m = painter()-&gt;combinedTransform();
<a name="l00668"></a>00668         QRectF mr = m.mapRect(r);
<a name="l00669"></a>00669 
<a name="l00670"></a>00670         <span class="keywordtype">double</span> w = (double)pix.width(), h = (double)pix.height();
<a name="l00671"></a>00671         QSizeF sz = QSizeF(w, h);
<a name="l00672"></a>00672 
<a name="l00673"></a>00673         Bitmap *bm = <a class="code" href="_emf_engine_plus_8cpp.html#2cd7d484029373b8c70e7e1dc161fcae">pixToBitmap</a>(pix.copy(QRectF(QPointF(0, 0), sz).toAlignedRect()), painter()-&gt;opacity());
<a name="l00674"></a>00674 
<a name="l00675"></a>00675         <span class="keywordtype">int</span> rx = ceil(mr.width()/w), ry = ceil(mr.height()/h);
<a name="l00676"></a>00676         <span class="keywordtype">double</span> x0 = mr.x() + p.x(), y0 = mr.y() + p.y();
<a name="l00677"></a>00677         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ry; i++){
<a name="l00678"></a>00678                 <span class="keywordtype">double</span> y = y0 + i*h;
<a name="l00679"></a>00679                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; rx; j++){
<a name="l00680"></a>00680                         QRectF dr = QRectF(QPointF(x0 + j*w, y), sz);
<a name="l00681"></a>00681                         QPolygonF poly = QPolygonF() &lt;&lt; dr.topLeft() &lt;&lt; dr.topRight() &lt;&lt; dr.bottomRight() &lt;&lt; dr.bottomLeft();
<a name="l00682"></a>00682                         PointF destPoints[] = {PointF(poly.at(0).x(), poly.at(0).y()),
<a name="l00683"></a>00683                                                                 PointF(poly.at(1).x(), poly.at(1).y()),
<a name="l00684"></a>00684                                                                 PointF(poly.at(3).x(), poly.at(3).y())};
<a name="l00685"></a>00685                         d_grx-&gt;DrawImage(bm, destPoints, 3);
<a name="l00686"></a>00686                 }
<a name="l00687"></a>00687         }
<a name="l00688"></a>00688 
<a name="l00689"></a>00689         <span class="keyword">delete</span> bm;
<a name="l00690"></a>00690 
<a name="l00691"></a>00691         resetClipping();
<a name="l00692"></a>00692 }
<a name="l00693"></a>00693 
<a name="l00694"></a>00694 TextureBrush * EmfPaintEngine::textureBrush(QPixmap pix, QColor brushColor)
<a name="l00695"></a>00695 {
<a name="l00696"></a>00696         <span class="comment">// If the brush uses a monochrome bitmap then use the brush color to create a colored image from it</span>
<a name="l00697"></a>00697         <span class="keywordflow">if</span> (pix.isQBitmap()){
<a name="l00698"></a>00698                 QImage srcBitmap = pix.toImage();
<a name="l00699"></a>00699                 QImage colorImage(srcBitmap.size(), QImage::Format_RGB32);
<a name="l00700"></a>00700                 <span class="comment">// Build the colored image by iterating all source pixels</span>
<a name="l00701"></a>00701                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; srcBitmap.height(); y++){
<a name="l00702"></a>00702                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; srcBitmap.width(); x++){
<a name="l00703"></a>00703                                 <span class="comment">// Replace all color1 pixels with the brush color</span>
<a name="l00704"></a>00704                                 QRgb pixel = srcBitmap.pixel(x, y);
<a name="l00705"></a>00705                                 <span class="keywordflow">if</span> (pixel == QColor(Qt::color1).rgb())
<a name="l00706"></a>00706                                         pixel = brushColor.rgb();
<a name="l00707"></a>00707 
<a name="l00708"></a>00708                                 colorImage.setPixel(x, y, pixel);
<a name="l00709"></a>00709                         }
<a name="l00710"></a>00710                 }
<a name="l00711"></a>00711                 pix = QPixmap::fromImage(colorImage);
<a name="l00712"></a>00712         }
<a name="l00713"></a>00713 
<a name="l00714"></a>00714         Bitmap *bm = <a class="code" href="_emf_engine_plus_8cpp.html#2cd7d484029373b8c70e7e1dc161fcae">pixToBitmap</a>(pix, painter()-&gt;opacity());
<a name="l00715"></a>00715         TextureBrush *tb = <span class="keyword">new</span> TextureBrush(bm);
<a name="l00716"></a>00716         <span class="keyword">delete</span> bm;
<a name="l00717"></a>00717         <span class="keywordflow">return</span> tb;
<a name="l00718"></a>00718 }
<a name="l00719"></a>00719 
<a name="l00720"></a><a class="code" href="class_emf_paint_engine.html#12336b6a6bd3c70dac37e9565caf311e">00720</a> <span class="keywordtype">void</span> <a class="code" href="class_emf_paint_engine.html#93f15e424121922fc18c46082caec7a0">EmfPaintEngine::drawImage</a>(<span class="keyword">const</span> QRectF &amp; r, <span class="keyword">const</span> QImage &amp; image, <span class="keyword">const</span> QRectF &amp; sr, Qt::ImageConversionFlags flags)
<a name="l00721"></a>00721 {
<a name="l00722"></a>00722         <a class="code" href="class_emf_paint_engine.html#a35f167a09b015d9e9805d9aaf1777ae">drawPixmap</a>(r, QPixmap::fromImage(image, flags), sr);
<a name="l00723"></a>00723 }
<a name="l00724"></a>00724 
<a name="l00725"></a>00725 <span class="keywordtype">void</span> EmfPaintEngine::setClipping()
<a name="l00726"></a>00726 {
<a name="l00727"></a>00727         <span class="keywordflow">if</span> (painter()-&gt;testRenderHint(QPainter::Antialiasing))
<a name="l00728"></a>00728                 d_grx-&gt;SetSmoothingMode(SmoothingModeAntiAlias);
<a name="l00729"></a>00729 
<a name="l00730"></a>00730         <span class="keywordflow">if</span> (painter()-&gt;hasClipping()){
<a name="l00731"></a>00731                 GraphicsPath *path = convertPath(painter()-&gt;clipPath());
<a name="l00732"></a>00732                 Region region(path);<span class="comment">// Set the clipping region of the Graphics object</span>
<a name="l00733"></a>00733                 d_grx-&gt;SetClip(&amp;region);
<a name="l00734"></a>00734                 <span class="keyword">delete</span> path;
<a name="l00735"></a>00735         }
<a name="l00736"></a>00736 }
<a name="l00737"></a>00737 
<a name="l00738"></a>00738 <span class="keywordtype">void</span> EmfPaintEngine::resetClipping()
<a name="l00739"></a>00739 {
<a name="l00740"></a>00740         d_grx-&gt;ResetClip();
<a name="l00741"></a>00741         d_grx-&gt;SetSmoothingMode(SmoothingModeDefault);
<a name="l00742"></a>00742 }
<a name="l00743"></a>00743 
<a name="l00744"></a>00744 Pen *EmfPaintEngine::convertPen(<span class="keyword">const</span> QPainter *painter)
<a name="l00745"></a>00745 {
<a name="l00746"></a>00746         QPen pen = painter-&gt;pen();
<a name="l00747"></a>00747         <span class="keywordflow">if</span> (pen.style() == Qt::NoPen || pen.color() == Qt::transparent)
<a name="l00748"></a>00748                 <span class="keywordflow">return</span> <span class="keyword">new</span> Pen(Color::Transparent);
<a name="l00749"></a>00749 
<a name="l00750"></a>00750         QTransform transform = painter-&gt;combinedTransform();
<a name="l00751"></a>00751         <span class="keywordtype">double</span> scaleFactor = qMax(transform.m11(), transform.m22());
<a name="l00752"></a>00752         <span class="keywordtype">double</span> width = (scaleFactor != 1.0) ? scaleFactor*pen.widthF() : pen.widthF();
<a name="l00753"></a>00753 
<a name="l00754"></a>00754         QColor color = pen.color();
<a name="l00755"></a>00755 
<a name="l00756"></a>00756         Pen *wpen = <span class="keyword">new</span> Pen(Color(color.alpha(), color.red(), color.green(), color.blue()), width);
<a name="l00757"></a>00757 
<a name="l00758"></a>00758         DashStyle style = DashStyleSolid;
<a name="l00759"></a>00759         <span class="keywordflow">switch</span> (pen.style()){
<a name="l00760"></a>00760                 <span class="keywordflow">case</span> Qt::SolidLine:
<a name="l00761"></a>00761                         style = DashStyleSolid;
<a name="l00762"></a>00762                 <span class="keywordflow">break</span>;
<a name="l00763"></a>00763 
<a name="l00764"></a>00764                 <span class="keywordflow">case</span> Qt::DashLine:
<a name="l00765"></a>00765                         style = DashStyleDash;
<a name="l00766"></a>00766                 <span class="keywordflow">break</span>;
<a name="l00767"></a>00767 
<a name="l00768"></a>00768                 <span class="keywordflow">case</span> Qt::DotLine:
<a name="l00769"></a>00769                         style = DashStyleDot;
<a name="l00770"></a>00770                 <span class="keywordflow">break</span>;
<a name="l00771"></a>00771 
<a name="l00772"></a>00772                 <span class="keywordflow">case</span> Qt::DashDotLine:
<a name="l00773"></a>00773                         style = DashStyleDashDot;
<a name="l00774"></a>00774                 <span class="keywordflow">break</span>;
<a name="l00775"></a>00775 
<a name="l00776"></a>00776                 <span class="keywordflow">case</span> Qt::DashDotDotLine:
<a name="l00777"></a>00777                         style = DashStyleDashDotDot;
<a name="l00778"></a>00778                 <span class="keywordflow">break</span>;
<a name="l00779"></a>00779 
<a name="l00780"></a>00780                 <span class="keywordflow">case</span> Qt::CustomDashLine:
<a name="l00781"></a>00781                 {
<a name="l00782"></a>00782                         style = DashStyleCustom;
<a name="l00783"></a>00783                         QVector&lt;qreal&gt; pattern = pen.dashPattern();
<a name="l00784"></a>00784                         <span class="keywordtype">int</span> count = 0, pCount = pattern.count();
<a name="l00785"></a>00785                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; pCount; i++){
<a name="l00786"></a>00786                                 <span class="keywordflow">if</span> (pattern.at(i) &gt; 0)<span class="comment">//avoid zero elements</span>
<a name="l00787"></a>00787                                         count++;
<a name="l00788"></a>00788                         }
<a name="l00789"></a>00789 
<a name="l00790"></a>00790                         REAL *dashVals = <span class="keyword">new</span> REAL[count];
<a name="l00791"></a>00791                         <span class="keywordtype">int</span> aux = 0;
<a name="l00792"></a>00792                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; pCount; i++){
<a name="l00793"></a>00793                                 <span class="keywordflow">if</span> (pattern.at(i) &gt; 0)
<a name="l00794"></a>00794                                         dashVals[aux++] = pattern.at(i);
<a name="l00795"></a>00795                         }
<a name="l00796"></a>00796 
<a name="l00797"></a>00797                         wpen-&gt;SetDashPattern(dashVals, count);
<a name="l00798"></a>00798                         <span class="keyword">delete</span> [] dashVals;
<a name="l00799"></a>00799                         <span class="keywordflow">break</span>;
<a name="l00800"></a>00800                 }
<a name="l00801"></a>00801 
<a name="l00802"></a>00802                 <span class="keywordflow">default</span>:
<a name="l00803"></a>00803                 <span class="keywordflow">break</span>;
<a name="l00804"></a>00804         }
<a name="l00805"></a>00805         wpen-&gt;SetDashStyle(style);
<a name="l00806"></a>00806         wpen-&gt;SetDashOffset(pen.dashOffset());
<a name="l00807"></a>00807 
<a name="l00808"></a>00808         LineCap capStyle = LineCapFlat;
<a name="l00809"></a>00809         DashCap dashStyle = DashCapFlat;
<a name="l00810"></a>00810         <span class="keywordflow">switch</span> (pen.capStyle()){
<a name="l00811"></a>00811                 <span class="keywordflow">case</span> Qt::FlatCap:
<a name="l00812"></a>00812                 <span class="keywordflow">break</span>;
<a name="l00813"></a>00813 
<a name="l00814"></a>00814                 <span class="keywordflow">case</span> Qt::SquareCap:
<a name="l00815"></a>00815                         capStyle = LineCapSquare;
<a name="l00816"></a>00816                 <span class="keywordflow">break</span>;
<a name="l00817"></a>00817 
<a name="l00818"></a>00818                 <span class="keywordflow">case</span> Qt::RoundCap:
<a name="l00819"></a>00819                         capStyle = LineCapRound;
<a name="l00820"></a>00820                         dashStyle = DashCapRound;
<a name="l00821"></a>00821                 <span class="keywordflow">break</span>;
<a name="l00822"></a>00822 
<a name="l00823"></a>00823                 <span class="keywordflow">default</span>:
<a name="l00824"></a>00824                 <span class="keywordflow">break</span>;
<a name="l00825"></a>00825         }
<a name="l00826"></a>00826         wpen-&gt;SetStartCap(capStyle);
<a name="l00827"></a>00827         wpen-&gt;SetEndCap(capStyle);
<a name="l00828"></a>00828         wpen-&gt;SetDashCap(dashStyle);
<a name="l00829"></a>00829 
<a name="l00830"></a>00830         LineJoin joinStyle = LineJoinMiter;
<a name="l00831"></a>00831         <span class="keywordflow">switch</span> (pen.joinStyle()){
<a name="l00832"></a>00832                 <span class="keywordflow">case</span> Qt::MiterJoin:
<a name="l00833"></a>00833                 <span class="keywordflow">break</span>;
<a name="l00834"></a>00834 
<a name="l00835"></a>00835                 <span class="keywordflow">case</span> Qt::BevelJoin:
<a name="l00836"></a>00836                         joinStyle = LineJoinBevel;
<a name="l00837"></a>00837                 <span class="keywordflow">break</span>;
<a name="l00838"></a>00838 
<a name="l00839"></a>00839                 <span class="keywordflow">case</span> Qt::RoundJoin:
<a name="l00840"></a>00840                         joinStyle = LineJoinRound;
<a name="l00841"></a>00841                 <span class="keywordflow">break</span>;
<a name="l00842"></a>00842 
<a name="l00843"></a>00843                 <span class="keywordflow">case</span> Qt::SvgMiterJoin:
<a name="l00844"></a>00844                         joinStyle = LineJoinMiter;
<a name="l00845"></a>00845                 <span class="keywordflow">break</span>;
<a name="l00846"></a>00846 
<a name="l00847"></a>00847                 <span class="keywordflow">default</span>:
<a name="l00848"></a>00848                         <span class="keywordflow">break</span>;
<a name="l00849"></a>00849         }
<a name="l00850"></a>00850         wpen-&gt;SetLineJoin(joinStyle);
<a name="l00851"></a>00851 
<a name="l00852"></a>00852         <span class="keywordflow">if</span> (joinStyle == LineJoinMiter)
<a name="l00853"></a>00853                 wpen-&gt;SetMiterLimit(pen.miterLimit());
<a name="l00854"></a>00854 
<a name="l00855"></a>00855         <span class="keywordflow">if</span> (pen.brush().style() != Qt::NoBrush)
<a name="l00856"></a>00856                 wpen-&gt;SetBrush(convertBrush(pen.brush()));
<a name="l00857"></a>00857 
<a name="l00858"></a>00858         <span class="keywordflow">return</span> wpen;
<a name="l00859"></a>00859 }
<a name="l00860"></a>00860 
<a name="l00861"></a>00861 Brush *EmfPaintEngine::convertBrush(<span class="keyword">const</span> QBrush&amp; brush, GraphicsPath *origPath)
<a name="l00862"></a>00862 {
<a name="l00863"></a>00863         QColor c = brush.color();
<a name="l00864"></a>00864         Color color(c.alpha(), c.red(), c.green(), c.blue());
<a name="l00865"></a>00865 
<a name="l00866"></a>00866         <span class="keywordflow">switch</span> (brush.style()){
<a name="l00867"></a>00867                 <span class="keywordflow">case</span> Qt::NoBrush:
<a name="l00868"></a>00868                         <span class="keywordflow">return</span> <span class="keyword">new</span> SolidBrush(Color::Transparent);
<a name="l00869"></a>00869                 <span class="keywordflow">break</span>;
<a name="l00870"></a>00870                 <span class="keywordflow">case</span> Qt::SolidPattern:
<a name="l00871"></a>00871                         <span class="keywordflow">return</span> <span class="keyword">new</span> SolidBrush(color);
<a name="l00872"></a>00872                 <span class="keywordflow">break</span>;
<a name="l00873"></a>00873                 <span class="keywordflow">case</span> Qt::Dense1Pattern:
<a name="l00874"></a>00874                         <span class="keywordflow">return</span> <span class="keyword">new</span> HatchBrush(HatchStyle10Percent, Color::White, color);
<a name="l00875"></a>00875                 <span class="keywordflow">break</span>;
<a name="l00876"></a>00876                 <span class="keywordflow">case</span> Qt::Dense2Pattern:
<a name="l00877"></a>00877                         <span class="keywordflow">return</span> <span class="keyword">new</span> HatchBrush(HatchStyle20Percent, Color::White, color);
<a name="l00878"></a>00878                 <span class="keywordflow">break</span>;
<a name="l00879"></a>00879                 <span class="keywordflow">case</span> Qt::Dense3Pattern:
<a name="l00880"></a>00880                         <span class="keywordflow">return</span> <span class="keyword">new</span> HatchBrush(HatchStyle30Percent, Color::White, color);
<a name="l00881"></a>00881                 <span class="keywordflow">break</span>;
<a name="l00882"></a>00882                 <span class="keywordflow">case</span> Qt::Dense4Pattern:
<a name="l00883"></a>00883                         <span class="keywordflow">return</span> <span class="keyword">new</span> HatchBrush(HatchStyle50Percent, Color::White, color);
<a name="l00884"></a>00884                 <span class="keywordflow">break</span>;
<a name="l00885"></a>00885                 <span class="keywordflow">case</span> Qt::Dense5Pattern:
<a name="l00886"></a>00886                         <span class="keywordflow">return</span> <span class="keyword">new</span> HatchBrush(HatchStyle60Percent, Color::White, color);
<a name="l00887"></a>00887                 <span class="keywordflow">break</span>;
<a name="l00888"></a>00888                 <span class="keywordflow">case</span> Qt::Dense6Pattern:
<a name="l00889"></a>00889                         <span class="keywordflow">return</span> <span class="keyword">new</span> HatchBrush(HatchStyle75Percent, Color::White, color);
<a name="l00890"></a>00890                 <span class="keywordflow">break</span>;
<a name="l00891"></a>00891                 <span class="keywordflow">case</span> Qt::Dense7Pattern:
<a name="l00892"></a>00892                         <span class="keywordflow">return</span> <span class="keyword">new</span> HatchBrush(HatchStyle80Percent, Color::White, color);
<a name="l00893"></a>00893                 <span class="keywordflow">break</span>;
<a name="l00894"></a>00894                 <span class="keywordflow">case</span> Qt::HorPattern:
<a name="l00895"></a>00895                         <span class="keywordflow">return</span> <span class="keyword">new</span> HatchBrush(HatchStyleHorizontal, color, Color::Transparent);
<a name="l00896"></a>00896                 <span class="keywordflow">break</span>;
<a name="l00897"></a>00897                 <span class="keywordflow">case</span> Qt::VerPattern:
<a name="l00898"></a>00898                         <span class="keywordflow">return</span> <span class="keyword">new</span> HatchBrush(HatchStyleVertical, color, Color::Transparent);
<a name="l00899"></a>00899                 <span class="keywordflow">break</span>;
<a name="l00900"></a>00900                 <span class="keywordflow">case</span> Qt::CrossPattern:
<a name="l00901"></a>00901                         <span class="keywordflow">return</span> <span class="keyword">new</span> HatchBrush(HatchStyleCross, color, Color::Transparent);
<a name="l00902"></a>00902                 <span class="keywordflow">break</span>;
<a name="l00903"></a>00903                 <span class="keywordflow">case</span> Qt::BDiagPattern:
<a name="l00904"></a>00904                         <span class="keywordflow">return</span> <span class="keyword">new</span> HatchBrush(HatchStyleBackwardDiagonal, color, Color::Transparent);
<a name="l00905"></a>00905                 <span class="keywordflow">break</span>;
<a name="l00906"></a>00906                 <span class="keywordflow">case</span> Qt::FDiagPattern:
<a name="l00907"></a>00907                         <span class="keywordflow">return</span> <span class="keyword">new</span> HatchBrush(HatchStyleForwardDiagonal, color, Color::Transparent);
<a name="l00908"></a>00908                 <span class="keywordflow">break</span>;
<a name="l00909"></a>00909                 <span class="keywordflow">case</span> Qt::DiagCrossPattern:
<a name="l00910"></a>00910                         <span class="keywordflow">return</span> <span class="keyword">new</span> HatchBrush(HatchStyleDiagonalCross, color, Color::Transparent);
<a name="l00911"></a>00911                 <span class="keywordflow">break</span>;
<a name="l00912"></a>00912 
<a name="l00913"></a>00913                 <span class="keywordflow">case</span> Qt::LinearGradientPattern:
<a name="l00914"></a>00914                 {
<a name="l00915"></a>00915                         <span class="keyword">const</span> QLinearGradient *qtgradient = (<span class="keyword">const</span> QLinearGradient *)brush.gradient();
<a name="l00916"></a>00916                         QGradientStops stops = qtgradient-&gt;stops();
<a name="l00917"></a>00917                         QColor fc = stops.first().second;
<a name="l00918"></a>00918                         QColor lc = stops.last().second;
<a name="l00919"></a>00919                         QPointF sp = qtgradient-&gt;start();
<a name="l00920"></a>00920                         QPointF ep = qtgradient-&gt;finalStop();
<a name="l00921"></a>00921 
<a name="l00922"></a>00922                         PointF start, <a class="code" href="class_emf_paint_engine.html#121bcc1139d6a38294d27e210aff5708">end</a>;
<a name="l00923"></a>00923                         QGradient::CoordinateMode mode = qtgradient-&gt;coordinateMode();
<a name="l00924"></a>00924                         <span class="keywordflow">if</span> (mode == QGradient::ObjectBoundingMode){
<a name="l00925"></a>00925                                 <span class="keywordflow">if</span> (origPath){
<a name="l00926"></a>00926                                         RectF rect;
<a name="l00927"></a>00927                                         origPath-&gt;GetBounds(&amp;rect);<span class="comment">//Get the path's bounding rectangle.</span>
<a name="l00928"></a>00928                                         <span class="keywordtype">double</span> x = rect.GetLeft(), y = rect.GetTop();
<a name="l00929"></a>00929                                         <span class="keywordtype">double</span> w = rect.Width, h = rect.Height;
<a name="l00930"></a>00930                                         start = PointF(x + w*sp.x(), y + h*sp.y());
<a name="l00931"></a>00931                                         end = PointF(x + w*ep.x(), y + h*ep.y());
<a name="l00932"></a>00932                                 }
<a name="l00933"></a>00933                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mode == QGradient::StretchToDeviceMode){
<a name="l00934"></a>00934                                 <span class="keywordtype">double</span> w = paintDevice()-&gt;width(), h = paintDevice()-&gt;height();
<a name="l00935"></a>00935                                 start = PointF(w*sp.x(), h*sp.y());
<a name="l00936"></a>00936                                 end = PointF(w*ep.x(), h*ep.y());
<a name="l00937"></a>00937                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mode == QGradient::LogicalMode){
<a name="l00938"></a>00938                                 QTransform m = painter()-&gt;combinedTransform();
<a name="l00939"></a>00939                                 sp = m.map(sp);
<a name="l00940"></a>00940                                 ep = m.map(ep);
<a name="l00941"></a>00941                                 start = PointF(sp.x(), sp.y());
<a name="l00942"></a>00942                                 end = PointF(ep.x(), ep.y());
<a name="l00943"></a>00943                         }
<a name="l00944"></a>00944 
<a name="l00945"></a>00945                         LinearGradientBrush *linGrBrush = <span class="keyword">new</span> LinearGradientBrush(start, end,
<a name="l00946"></a>00946                                                         Color(fc.alpha(), fc.red(), fc.green(), fc.blue()),
<a name="l00947"></a>00947                                                         Color(lc.alpha(), lc.red(), lc.green(), lc.blue()));
<a name="l00948"></a>00948 
<a name="l00949"></a>00949                         <span class="keywordtype">int</span> count = stops.count();
<a name="l00950"></a>00950                         REAL *positions = <span class="keyword">new</span> REAL[count];
<a name="l00951"></a>00951                         Color *colors = <span class="keyword">new</span> Color[count];
<a name="l00952"></a>00952                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; count; i++){
<a name="l00953"></a>00953                                 QGradientStop stop = stops.at(i);
<a name="l00954"></a>00954                                 positions[i] = stop.first;
<a name="l00955"></a>00955                                 QColor c = stop.second;
<a name="l00956"></a>00956                                 colors[i] = Color(c.alpha(), c.red(), c.green(), c.blue());
<a name="l00957"></a>00957                         }
<a name="l00958"></a>00958                         linGrBrush-&gt;SetInterpolationColors(colors, positions, count);
<a name="l00959"></a>00959                         <span class="keyword">delete</span> [] colors;
<a name="l00960"></a>00960                         <span class="keyword">delete</span> [] positions;
<a name="l00961"></a>00961                         <span class="keywordflow">return</span> linGrBrush;
<a name="l00962"></a>00962                 }
<a name="l00963"></a>00963                 <span class="keywordflow">break</span>;
<a name="l00964"></a>00964 
<a name="l00965"></a>00965                 <span class="keywordflow">case</span> Qt::ConicalGradientPattern:
<a name="l00966"></a>00966                 {
<a name="l00967"></a>00967                         <span class="keywordtype">double</span> x = 0, y = 0, w = 0, h = 0;
<a name="l00968"></a>00968                         <span class="keywordflow">if</span> (origPath){
<a name="l00969"></a>00969                                 RectF rect;<span class="comment">//Get the path's bounding rectangle.</span>
<a name="l00970"></a>00970                                 origPath-&gt;GetBounds(&amp;rect);
<a name="l00971"></a>00971                                 x = rect.GetLeft();
<a name="l00972"></a>00972                                 y = rect.GetTop();
<a name="l00973"></a>00973                                 w = rect.Width;
<a name="l00974"></a>00974                                 h = rect.Height;
<a name="l00975"></a>00975                         }
<a name="l00976"></a>00976 
<a name="l00977"></a>00977                         QPixmap pix = QPixmap((<span class="keywordtype">int</span>)w, (<span class="keywordtype">int</span>)h);
<a name="l00978"></a>00978                         QPainter paint(&amp;pix);
<a name="l00979"></a>00979                         paint.setTransform(painter()-&gt;combinedTransform());
<a name="l00980"></a>00980                         paint.translate(-x, -y);
<a name="l00981"></a>00981                         paint.fillRect(QRectF(0, 0, x + w, y + h), brush);
<a name="l00982"></a>00982                         paint.end();
<a name="l00983"></a>00983 
<a name="l00984"></a>00984                         TextureBrush *pBrush = <span class="keyword">new</span> TextureBrush(<a class="code" href="_emf_engine_plus_8cpp.html#2cd7d484029373b8c70e7e1dc161fcae">pixToBitmap</a>(pix, painter()-&gt;opacity()));
<a name="l00985"></a>00985                         pBrush-&gt;TranslateTransform(x, y);
<a name="l00986"></a>00986                         <span class="keywordflow">return</span> pBrush;
<a name="l00987"></a>00987                 }
<a name="l00988"></a>00988                 <span class="keywordflow">break</span>;
<a name="l00989"></a>00989 
<a name="l00990"></a>00990                 <span class="keywordflow">case</span> Qt::RadialGradientPattern:
<a name="l00991"></a>00991                 {
<a name="l00992"></a>00992                         <span class="keyword">const</span> QRadialGradient *qtgradient = (<span class="keyword">const</span> QRadialGradient *)brush.gradient();
<a name="l00993"></a>00993                         QGradientStops stops = qtgradient-&gt;stops();
<a name="l00994"></a>00994 
<a name="l00995"></a>00995                         QTransform m = painter()-&gt;combinedTransform();
<a name="l00996"></a>00996                         QPointF center = m.map(qtgradient-&gt;center());
<a name="l00997"></a>00997                         QPointF focalPoint = m.map(qtgradient-&gt;focalPoint());
<a name="l00998"></a>00998                         REAL radius = qtgradient-&gt;radius();
<a name="l00999"></a>00999                         REAL diameter = 2*qtgradient-&gt;radius();
<a name="l01000"></a>01000 
<a name="l01001"></a>01001                         GraphicsPath path;
<a name="l01002"></a>01002                         path.AddEllipse(center.x() - radius, center.y() - radius, diameter, diameter);
<a name="l01003"></a>01003 
<a name="l01004"></a>01004                         <span class="comment">// Use the path to construct a brush.</span>
<a name="l01005"></a>01005                         PathGradientBrush *pthGrBrush = <span class="keyword">new</span> PathGradientBrush(&amp;path);
<a name="l01006"></a>01006                         pthGrBrush-&gt;SetCenterPoint(PointF(focalPoint.x(), focalPoint.y()));
<a name="l01007"></a>01007 
<a name="l01008"></a>01008                         <span class="keywordtype">int</span> count = stops.count();
<a name="l01009"></a>01009                         Color *colors = <span class="keyword">new</span> Color[count];
<a name="l01010"></a>01010                         REAL *interpPositions = <span class="keyword">new</span> REAL[count];
<a name="l01011"></a>01011                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; count; i++){
<a name="l01012"></a>01012                                 QGradientStop stop = stops[i];
<a name="l01013"></a>01013                                 interpPositions[i] = stop.first;
<a name="l01014"></a>01014                                 QColor sc = stop.second;
<a name="l01015"></a>01015                                 colors[count - i - 1] = Color(sc.alpha(), sc.red(), sc.green(), sc.blue());
<a name="l01016"></a>01016                         }
<a name="l01017"></a>01017                         pthGrBrush-&gt;SetInterpolationColors(colors, interpPositions, count);
<a name="l01018"></a>01018 
<a name="l01019"></a>01019                         <span class="keywordflow">if</span> (origPath){
<a name="l01020"></a>01020                                 SolidBrush br(colors[0]);
<a name="l01021"></a>01021                                 d_grx-&gt;FillPath(&amp;br, origPath);
<a name="l01022"></a>01022                         }
<a name="l01023"></a>01023                         <span class="keyword">delete</span> [] colors;
<a name="l01024"></a>01024                         <span class="keyword">delete</span> [] interpPositions;
<a name="l01025"></a>01025                         <span class="keywordflow">return</span> pthGrBrush;
<a name="l01026"></a>01026                 }
<a name="l01027"></a>01027                 <span class="keywordflow">break</span>;
<a name="l01028"></a>01028 
<a name="l01029"></a>01029                 <span class="keywordflow">case</span> Qt::TexturePattern:
<a name="l01030"></a>01030                 {
<a name="l01031"></a>01031                         TextureBrush *pBrush = textureBrush(brush.texture(), brush.color());
<a name="l01032"></a>01032                         <span class="comment">//First apply the brush transformation to our GDI+ brush</span>
<a name="l01033"></a>01033                         Gdiplus::Matrix *m = convertTransform(brush.transform());<span class="comment">//???Should toAffine() be used instead???;</span>
<a name="l01034"></a>01034                         pBrush-&gt;SetTransform(m);
<a name="l01035"></a>01035                         <span class="keyword">delete</span> m;
<a name="l01036"></a>01036                         <span class="comment">//Then apply the painter transformation to our GDI+ brush</span>
<a name="l01037"></a>01037                         m = convertTransform(painter()-&gt;combinedTransform());
<a name="l01038"></a>01038                         pBrush-&gt;MultiplyTransform(m, MatrixOrderAppend);
<a name="l01039"></a>01039                         <span class="keyword">delete</span> m;
<a name="l01040"></a>01040                         <span class="keywordflow">return</span> pBrush;
<a name="l01041"></a>01041                 }
<a name="l01042"></a>01042                 <span class="keywordflow">break</span>;
<a name="l01043"></a>01043 
<a name="l01044"></a>01044                 <span class="keywordflow">default</span>:
<a name="l01045"></a>01045                 <span class="keywordflow">break</span>;
<a name="l01046"></a>01046         }
<a name="l01047"></a>01047 
<a name="l01048"></a>01048         <span class="keywordflow">return</span> <span class="keyword">new</span> SolidBrush(color);
<a name="l01049"></a>01049 }
<a name="l01050"></a>01050 
<a name="l01051"></a>01051 Gdiplus::Matrix* EmfPaintEngine::convertTransform(<span class="keyword">const</span> QTransform&amp; m)
<a name="l01052"></a>01052 {
<a name="l01053"></a>01053         <span class="keywordflow">return</span> <span class="keyword">new</span> Gdiplus::Matrix(m.m11(), m.m12(), m.m21(), m.m22(), m.dx(), m.dy());
<a name="l01054"></a>01054 }
<a name="l01055"></a>01055 
<a name="l01056"></a>01056 GraphicsPath* EmfPaintEngine::convertPath(<span class="keyword">const</span> QPainterPath&amp; path)
<a name="l01057"></a>01057 {
<a name="l01058"></a>01058         <span class="keywordtype">int</span> points = path.elementCount();
<a name="l01059"></a>01059         PointF *pts = <span class="keyword">new</span> PointF[points];
<a name="l01060"></a>01060         BYTE *types = <span class="keyword">new</span> BYTE[points];
<a name="l01061"></a>01061 
<a name="l01062"></a>01062         QTransform m = painter()-&gt;combinedTransform();
<a name="l01063"></a>01063         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; points; i++){
<a name="l01064"></a>01064                 QPainterPath::Element el = path.elementAt(i);
<a name="l01065"></a>01065                 QPointF p = m.map(QPointF(el.x, el.y));
<a name="l01066"></a>01066                 pts[i] = PointF(p.x(), p.y());
<a name="l01067"></a>01067 
<a name="l01068"></a>01068                 <span class="keywordflow">switch</span>(el.type){
<a name="l01069"></a>01069                         <span class="keywordflow">case</span> QPainterPath::MoveToElement:
<a name="l01070"></a>01070                                 types[i] = PathPointTypeStart;
<a name="l01071"></a>01071                         <span class="keywordflow">break</span>;
<a name="l01072"></a>01072 
<a name="l01073"></a>01073                         <span class="keywordflow">case</span> QPainterPath::LineToElement:
<a name="l01074"></a>01074                                 types[i] = PathPointTypeLine;
<a name="l01075"></a>01075                         <span class="keywordflow">break</span>;
<a name="l01076"></a>01076 
<a name="l01077"></a>01077                         <span class="keywordflow">case</span> QPainterPath::CurveToElement:
<a name="l01078"></a>01078                                 types[i] = PathPointTypeBezier;
<a name="l01079"></a>01079                         <span class="keywordflow">break</span>;
<a name="l01080"></a>01080 
<a name="l01081"></a>01081                         <span class="keywordflow">case</span> QPainterPath::CurveToDataElement:
<a name="l01082"></a>01082                                 types[i] = PathPointTypeBezier;
<a name="l01083"></a>01083                         <span class="keywordflow">break</span>;
<a name="l01084"></a>01084                 }
<a name="l01085"></a>01085         }
<a name="l01086"></a>01086 
<a name="l01087"></a>01087         GraphicsPath *wpath = <span class="keyword">new</span> GraphicsPath(pts, types, points, (Gdiplus::FillMode)path.fillRule());
<a name="l01088"></a>01088 
<a name="l01089"></a>01089         <span class="keyword">delete</span> [] pts;
<a name="l01090"></a>01090         <span class="keyword">delete</span> [] types;
<a name="l01091"></a>01091         <span class="keywordflow">return</span> wpath;
<a name="l01092"></a>01092 }
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Dec 5 12:19:58 2014 for EmfEngine Commercial by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
